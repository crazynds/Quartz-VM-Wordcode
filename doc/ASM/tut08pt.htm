<html>

<head>
<title>Tutorial 8 - Adam Hyde</title>
</head>

<body bgcolor="#00FFFF">
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><strong><big>Tutorial de Assembler de
    Adam Hyde 1.0</big></strong><p><small>PARTE 8</small><br>
    <small>Traduzido por Renato Nunes Bastos</small></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>

<p>Versão&nbsp;&nbsp; :&nbsp; 1.2<br>
Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; 28-06-1996 / online by Renato 03-11-1998<br>
Contato&nbsp; :&nbsp; blackcat@vale.faroc.com.au<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
http://www.faroc.com.au/~blackcat<br>
;Renato&nbsp; :&nbsp;
<a href="mailto:rnbastos@ig.com.br">rnbastos@ig.com.br</a>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://www.geocities.com/SiliconValley/Park/3174">http://www.geocities.com/SiliconValley/Park/3174</a></p>

<hr>

<p align="center"><a href="#estrut">Estruturas de Dados em Assembler</a> | <a
href="#refestrut">Referenciando Estruturas de Dados em Assembler</a> | <a href="#arrays">Criando
Arrays em Assembler</a> | <a href="#indexarrays">Indexando Arrays em Assembler</a> | <a
href="#oplog">Operadores Lógicos</a> | <a href="#demo">O Programa Demo</a></p>

<hr>

<p>Bem, bem-vindo de volta programadores de Assembler.&nbsp; Este tutorial está realmente
atrasado, e teria chegado muito mais tarde se não fosse por Bjorn Svensson, e muitos
outros como ele, que graças à sua determinação em adquirir Tutorial 8, me persuadiu a
escrever esta coisa. É claro, isto significa que eu provavelmente fracassei em todos meus
exames das últimas duas semanas, mas a vida é assim. :)<br>
</p>

<p>Ok, esta semana nós vamos realmente aprender algo.&nbsp; Vamos dar uma olhada &nbsp;
mais de perto em como podemos declarar variáveis, e aprofundar no mundo de
estruturas.&nbsp; Você aprenderá a criar arrays em Assembler, e este conceito é
reforçado com o <a href="tut8demo.zip">programa demonstrativo</a> que eu incluí - uma
rotina de fogo! </p>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><a name="estrut"><strong>ESTRUTURAS DE
    DADOS EM ASSEMBLER</strong></a></td>
  </tr>
</table>
</center></div>

<p>Bem, até agora você deveria saber que você pode usar o DB, (Declare Byte) e DW,
(Declare Word) para criar variáveis. Porém, até agora nós os temos usado como você
usaria a declaração de Const em Pascal. Quer dizer, temos usado isto para dar a um byte
ou a uma word um valor.</p>

<p>Ex.: </p>

<p>MyByte DB 10&nbsp; --&nbsp; que é o mesmo que&nbsp; --&nbsp; Const MyByte : Byte = 10;<br>
</p>

<p>Contudo, poderíamos dizer: </p>

<p>&nbsp;&nbsp; MyByte DB ? </p>

<p>...e então dizer depois:</p>

<p>&nbsp;&nbsp; MOV MyByte, 10<br>
</p>

<p>De fato DB realmente é muito poderoso. Há vários tutoriais atrás, quando você
estava aprendendo a escrever strings na tela, você viu algo desse tipo: </p>

<p>&nbsp;&nbsp; MyString DB 10, 13 &quot;This is a string$&quot;<br>
</p>

<p>Agora, o mais curioso de vocês provavelmente teria dito a si prórpio:
&quot;Peraí!...&nbsp; aquele cara do tutorial disse que DB declara um BYTE.&nbsp; Como é
que o DB pode declarar uma string, então &quot;?&nbsp; Bem, DB tem a habilidade de
reservar espaço&nbsp; para valores de vários bytes - de 1 a tantos bytes quanto você
precisa. </p>

<p>Você também pode ter desejado saber o que os números 10 e 13 antes do texto &nbsp;
representavam. Bem, dê uma olhada na sua tabela ASCII e veja o que são o 10 e &nbsp; o
13.&nbsp; Você notará que 10 é o Line Feed e o 13 é o Carriage Return. &nbsp;
Basicamente, é o mesmo que dizer: </p>

<p>&nbsp;&nbsp; MyString := #10 + #13 + 'This is a string';</p>

<p>em Pascal. </p>

<hr>

<p>Ok, então você viu como criar variáveis corretamente. Mas, e constantes?&nbsp; Bem,
em Assembler, constantes são conhecidas como Equates. Equates fazem a&nbsp; codificação
em Assembler muito mais fácil, e pode simplificar muito as coisas. Por exemplo, se eu
tivesse usado o seguinte em tutoriais anteriores: </p>

<p>&nbsp;&nbsp; LF&nbsp;&nbsp; EQU 10<br>
&nbsp;&nbsp; CR&nbsp;&nbsp; EQU 13</p>

<p>&nbsp;&nbsp; DB&nbsp;&nbsp; LF, CR &quot;Isso é uma string$&quot;<br>
</p>

<p>...as pessoas teriam entendido direito aquela coisa de 10 e 13. Mas, para fazer as
&nbsp; coisas um pouco mais complicadas, há ainda um outro modo que você pode usar para
dar valores a identificadores. Você pode fazer como você faria em BASIC: </p>

<p>&nbsp;&nbsp; Population&nbsp; = 4Ch<br>
&nbsp;&nbsp; Magnitude&nbsp;&nbsp; = 0<br>
</p>

<p>Basicamente, você pode ter em mente os seguintes pontos: 

<ul>
  <li>Uma vez que você tenha usado EQU para dar um valor a um identificador, você não pode <br>
    mudar isto.</li>
  <li>EQU pode ser usado para definir quase qualquer tipo - inclusive strings.&nbsp; <br>
    Contudo, você não pode fazer isto quando se usa um ' = '.&nbsp; Um ' = ' só pode <br>
    definir valores numéricos. </li>
  <li>Você pode usar EQU quase em qualquer lugar de seu programa. </li>
  <li>Valores definidos com ' = ' podem ser mudados. </li>
</ul>

<hr>

<p>E agora, vamos a um dos pontos mais macetosos de codificação em Assembler -
estruturas. Estruturas não são variáveis, são um TIPO - basicamente um esquema de uma
variável. </p>

<p>Como um exemplo, se você tivesse o seguinte em Pascal: </p>

<p>&nbsp;&nbsp; Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Record;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Day&nbsp;&nbsp;&nbsp; : Byte;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Month&nbsp; : Byte;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Year&nbsp;&nbsp; : Word;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End;&nbsp;&nbsp;&nbsp; { Record }</p>

<p>Você poderia representar isto em Assembler como segue: </p>

<p>&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB ?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Month&nbsp;&nbsp;&nbsp;&nbsp; DB ?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DW ?<br>
&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDS<br>
</p>

<p>Porém, um das vantagens de Assembler é que você pode inicializar todos ou alguns
&nbsp; dos campos da estrutura antes mesmo de você se referir à estrutura em seu &nbsp;
segmento de código. </p>

<p>Aquela estrutura acima poderia ser escrita facilmente como: <br>
</p>

<p>&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB ?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Month&nbsp;&nbsp;&nbsp;&nbsp; DB 6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DW 1996<br>
&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDS<br>
</p>

<p>Alguns pontos importantes para se lembrar são os seguintes: 

<ul>
  <li>Você pode declarar uma estrutura em qualquer lugar em seu código, embora <br>
    que, para um bom design, você deva colocá-los no segmento de dados, a menos que eles <br>
    só sejam usados por uma subrotina. </li>
  <li>Definir uma estrutura não reserva qualquer byte de memória para a mesma. Isso <br>
    só acontece quando você declara uma variável dessa estrutura - aí a memória é
    alocada.</li>
</ul>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><strong><a name="refestrut">REFERENCIANDO</a>
    ESTRUTURAS DE DADOS EM ASSEMBLER</strong></td>
  </tr>
</table>
</center></div>

<p>Bem, você viu como definir estruturas, mas como você se refere de verdade a elas em
seu código? </p>

<p>Tudo o que você tem a fazer, é colocar em algum lugar algumas linhas como as
seguintes em seu programa - de preferência no segmento de dados. </p>

<p>&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB 19<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Month&nbsp;&nbsp;&nbsp;&nbsp; DB 6<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DW 1996<br>
&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDS</p>

<p>&nbsp;&nbsp; Date_I_Passed_Physics&nbsp;&nbsp; Date &lt;&gt;&nbsp;&nbsp; ; Espero!<br>
</p>

<p>Neste momento, Date_I_Passed_Physics tem todos os seus três campos preenchidos. Dia é
setado para 19, Mês para 6 e Ano para 1996. Agora, o que são esses
parênteses,&quot;&lt;&gt;&quot;, fazendo depois de data? - você pergunta.</p>

<p>Os parênteses nos apresentam um outro modo de alterar os conteúdos dos campos da
variável.&nbsp; Se eu tivesse escrito isto: </p>

<p>&nbsp;&nbsp; Date_I_Passed_Physics&nbsp;&nbsp; Date &lt;10,10,1900&gt;<br>
</p>

<p>...então os campos teriam sido mudados para os valores nos parênteses.
Alternativamente, teria sido possível fazer isto: </p>

<p>&nbsp;&nbsp; Date_I_Passed_Physics&nbsp;&nbsp; Date &lt;,10,&gt;&nbsp;&nbsp; ;<br>
</p>

<p>E só agora o campo de Mês foi mudado.&nbsp; Note que neste exemplo, a segunda
vírgula não era necessária, pois nós não mudamos outros campos posteriores. É sua
escolha, (e do compilador!), se deixar a segunda vírgula ou não. <br>
</p>

<p>Agora tudo isso tá indo muito bem, mas como você se estes valores em seu código?
Simplesmente basta dizer: </p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, [Date_I_Passed_Physics.Month]&nbsp;&nbsp;&nbsp; ; ou
algo como</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; [Date_I_Passed_Physics.Day], 5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ou até mesmo</p>

<p>&nbsp;&nbsp; CMP&nbsp;&nbsp; [Date_I_Passed_Physics.Year], 1996<br>
</p>

<p>Simples, né? </p>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><a name="arrays"><strong>CRIANDO ARRAYS
    EM ASSEMBLER</strong></a></td>
  </tr>
</table>
</center></div>

<p>Certo, arrays são bem fáceis de se implementar. Por exemplo, digamos que você
tivesse a seguintes estrutura de array em Pascal: </p>

<p>&nbsp;&nbsp; Var <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyArray: Array[0 ..19] of Word; <br>
</p>

<p>Para criar um array semelhante em Assembler, você tem que usar o operador DUP. &nbsp;
DUP, ou DUPlique Variável, tem a seguinte sintaxe: </p>

<p>&nbsp;&nbsp; þ &lt;rótulo&gt;&nbsp;&nbsp;&nbsp; &lt;diretiva&gt; &lt;contador&gt;
&nbsp; DUP&nbsp; (expressão)</p>

<p>&nbsp;&nbsp; Onde (expressão) é um valor opcional para inicializar o array. <br>
</p>

<p>Basicamente, aquele array no Pascal se pareceria com isso: </p>

<p>&nbsp;&nbsp; MyArray DW 20 DUP (?) <br>
</p>

<p>Ou, se você quisesse inicializar cada valor para zero, então você poderia dizer
isto: </p>

<p>&nbsp;&nbsp; MyArray DW 20 DUP (0) <br>
</p>

<p>E, como outro exemplo de como o Assembler é flexível, você poderia dizer algo desse
tipo: </p>

<p>&nbsp;&nbsp; MyArray DB 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,,, <br>
</p>

<p>...para criar um array de 10 bytes, com todos os dez elementos inicializados em 1, 2,
3... </p>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><a name="indexarrays"><strong>INDEXANDO
    ARRAYS EM ASSEMBLER</strong></a></td>
  </tr>
</table>
</center></div>

<p>Bem, agora que você já viu como criar arrays, eu suponho que você queira saber como
referenciar elementos individualmente. Bem, digamos que você tivesse o seguinte array:</p>

<p>&nbsp;&nbsp; OutroArray DB 50 DUP (?) <br>
</p>

<p>Se você quisesse mover o elemento 24 para, digamos, BL, então você poderia fazer
isto: </p>

<p>&nbsp;&nbsp; MOV BL, [OutroArray + 23]; Ou, seria possível dizer: </p>

<p>&nbsp;&nbsp; MOV AX, 23, <br>
&nbsp;&nbsp; MOV BL, [OutroArray + AX] <br>
</p>

<p>NOTA:&nbsp; Não esqueça que todos os arrays começam no elemento ZERO. Linguagens de
alto-nível como C e Pascal fazem você esquecer isto devido ao modo que eles deixam você
referenciar arrays.&nbsp; </p>

<hr>

<p>Agora, isso foi fácil, mas, e se OutroArray fosse de 50 WORDS, não BYTES? </p>

<p>&nbsp;&nbsp; OutroArray DW 50 DUP (?)&nbsp;&nbsp; ; como esse. <br>
</p>

<p>Bem, para acessar o elemento 24, você teria que multiplicar o valor de índice por
dois, e então somar isso a OutroArray para conseguir o elemento desejado. </p>

<p>&nbsp;&nbsp; MOV AX, 23 ; Acesse o elemento 24 <br>
&nbsp;&nbsp; SHL AX, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Multiplique AX por dois
<br>
&nbsp;&nbsp; MOV BX, [OutroArray + AX] ; Bote o elemento 24 em BX <br>
</p>

<p>Não é tão difícil assim, né? Porém, este método fica um pouco macetoso quando
você não tem cálculos fáceis para fazer quando o índice não é uma potência de
dois.</p>

<p>Digamos que você tivesse um array que tem um tamanho de elemento de 5 bytes. Se nós
quiséssemos conferir o sétimo elemento, nós teríamos que fazer algo assim: </p>

<p>&nbsp;&nbsp; MOV AX, 6 ; Pega o sétimo elemento <br>
&nbsp;&nbsp; MOV BX, 5 ; Cada elemento tem cinco bytes<br>
&nbsp;&nbsp; MUL BX ; AX = 6 x 5<br>
&nbsp;&nbsp; MOV DX, [YetAnotherArray + AX] ; Coloca o elemento 7 em DX <br>
</p>

<p>Porém, como eu disse antes, MUL não é um modo muito eficiente de codificação,
assim, substituir o MUL por um SHL 2 e um ADD seria a ordem do dia.</p>

<hr>

<p>Antes de continuarmos com mais alguma coisa, eu suponho que seja hora de&nbsp; falar
sobre números de ponto flutuante. Agora, números de ponto flutuantes podem ser
desajeitados para se manipular em Assembler, assim vê se não sai escrevendo aquele
programa de planilha eletrônica que você sempre quis, em código de máquina! Porém,
quando estiver trabalhando com mapeamento de textura, círculos e outras funções mais
complicadas, é inevitável que você precise de algo para declarar números de ponto
flutuante. </p>

<p>Digamos que quiséssemos armazenar Pi. Para declarar Pi, nós precisamos usar a
diretiva DT. Você poderia declarar Pi assim: </p>

<p>Pi DT 3.14 <br>
</p>

<p>DT na verdade reserva dez bytes de memória, assim seria possível declarar Pi com um
número maior de casas decimais. </p>

<p>Eu não vou entrar nas particularidades de números de ponto flutuante neste tutorial.
Quando nós precisarmos deles mais tarde, eu falo sobre isso.&nbsp; </p>

<hr>

<p>Certo, no último tutorial disse eu que eu daria algum tipo de resumo do que nós
cobrimos durante os últimos quatro meses.&nbsp; (Ei - isso é como se fosse um tutorial a
cada duas semanas, então talvez eles não tenham saído tão irregularmente, afinal de
contas!) </p>

<p>De qualquer maneira, eu vou falar sobre a parte de pegar e setar bits individuais
&nbsp; num registrador, porque este é um tópico importante que eu deveria ter coberto
há muito tempo atrás.&nbsp; </p>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><a name="oplog"><strong>OPERADORES
    LÓGICOS</strong></a></td>
  </tr>
</table>
</center></div>

<p>Certo, de volta ao Tutorial Cinco, eu dei as três tabelas verdade para E, OU e XOR. </p>

<p>(A propósito, em uma edição de Tutorial Cinco, eu errei a tabela para XOR,
amavelmente apontado por Keith Weatherby, assim se você não tem a versão mais atual, (V
1.3), então pegue agora.&nbsp; Por favor, embora eu tente o meu melhor para excluir
qualquer erro dos Tutoriais, alguns ficam com erros, assim se você achar algum, por favor
me avise. </p>

<p>Mas tenha certeza de que você tem as edições mais recentes dos tutoriais antes de
fazer isto!) </p>

<p>Certo, chega de meus erros. Essas tabelas se pareciam com estas: <br>
</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
AND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
XOR</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 AND 0 = 0&nbsp;&nbsp;&nbsp;&nbsp; 0 OR 0 = 0&nbsp;&nbsp;&nbsp;&nbsp; 0 XOR 0 = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 AND 1 = 0&nbsp;&nbsp;&nbsp;&nbsp; 0 OR 1 = 1&nbsp;&nbsp;&nbsp;&nbsp; 0 XOR 1 = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 AND 0 = 0&nbsp;&nbsp;&nbsp;&nbsp; 1 OR 0 = 1&nbsp;&nbsp;&nbsp;&nbsp; 1 XOR 0 = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 AND 1 = 1&nbsp;&nbsp;&nbsp;&nbsp; 1 OR 1 = 1&nbsp;&nbsp;&nbsp;&nbsp; 1 XOR 1 = 0<br>
</p>

<p>Isto está tudo muito bem, mas pra quê vamos usar isso? Bem, em primeiro lugar, vamos
dar uma olhada no que o AND pode fazer. Nós podemos usar o AND para mascarar bits em um
registrador ou variável, e assim setar e resetar bits individuais.</p>

<p>Como um exemplo, usaremos o AND para testar um valor de um único bit. Olhe os exemplos
seguintes, e veja como você pode usar AND para seus próprios fins. Um uso bom para AND
seria conferir se um caracter lido do teclado é uma maiúscula ou não.&nbsp; (Você pode
fazer isto, porque a diferença entre uma maiúscula e sua minúscula é de um bit. <br>
</p>

<p>&nbsp;&nbsp; Ex:&nbsp; 'A' =&nbsp; 65&nbsp;&nbsp; = 01000001<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'a' =&nbsp; 97&nbsp;&nbsp; =
01100001</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'S' =&nbsp; 83&nbsp;&nbsp; =
01010011<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 's' =&nbsp; 115&nbsp; = 01110011)</p>

<p>Assim, da mesma forma que você pode azer um AND de números binários, você poderia
usar uma aproximação semelhante para escrever uma rotina que confere se um caracter é
maiúsculo ou minúsculo. <br>
</p>

<p>&nbsp;&nbsp; Ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0101 0011
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0111 0011<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND 0010 0000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
AND 0010 0000</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0000 0000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0010 0000</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^ Essa é maiúscula ^^^
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^ Essa é minúscula ^^^<br>
</p>

<p>Agora, e o OR? O OR é geralmente usado depois de um AND, mas não tem que ser. &nbsp;
Você pode usar OR para mudar bits individuais em um registrador ou variável sem mudar
quaisquer um dos outros bits. Você poderia usar OR para escrever uma rotina para mudar um
caracter para maiúsculo se já não for, ou talvez para minúscula se fosse maiúscula. <br>
</p>

<p>&nbsp;&nbsp; Ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0101 0011<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OR 0010 0000</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp; 0111 0011</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^ S maiúsculo
agora foi mudado para s minúsculo ^^^<br>
</p>

<p>A combinação de AND/OR é um dos truques mais frequentemente usados no mundo do
Assember, assim tenha certeza de que você entendeu bem o conceito.&nbsp; Você me verá
freqüentemente usando-os, tirando proveito da velocidade das instruções. </p>

<p>Finalmente, e o XOR?&nbsp; Bem, o OU exclusivo pode ser às vezes muito útil. XOR pode
ser de útil para alternar bits individuaisentre 0 e 1 sem ter que saber qual o conteúdo
que cada bit tinha anteriormente. Lembre-se, como com OU, uma máscara de zero permite ao
bit original continuar com seu valor.</p>

<p>&nbsp;&nbsp; Ex:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1010 0010<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
XOR 1110 1011</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0100 1001<br>
</p>

<p>Faça alguma tentativa para aprender estes operadores binários, e o que eles fazem.
&nbsp; Eles são uma ferramenta inestimável quando se está trabalhando com números
binários. </p>

<p>OBS.:&nbsp; Para simplicidade, o Turbo Assembler lhe permite usar números binários em
seu código.&nbsp; Por exemplo, seria possível dizer, AND AX, 0001000b em vez de AND AX,
8h para testar o bit 3 de AX. Isto pode facilitar as coisas para você quando <br>
codificar. </p>

<hr>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><a name="demo"><strong>O PROGRAM
    DEMONSTRATIVO </strong></a></td>
  </tr>
</table>
</center></div>

<p>Certo, chega da parte chata - vamos ao programa demonstrativo que eu incluí! Eu pensei
que já era sem tempo escrever outra demonstração - 100% Assembler desta vez, e vamos a
uma rotina de fogo. Rotinas de fogo podem parecer bem&nbsp; efetivas, e são
surpreendentemente fáceis de se fazer, assim, pensei, por que não... </p>

<hr>

<p>Agora, os princípios de uma rotina de fogo são bastante simples.&nbsp; Você
basicamente faz o seguinte: 

<ul>
  <li>Crie um buffer com o qual você vai trabalhar&nbsp; </li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Este buffer pode ser quase de qualquer tamanho, entretanto
quanto menor você o fizer, o mais rápido seu programa será, e quanto maior você o
fizer, o mais bem definido o fogo será. Você precisa acertar um equilíbrio entre
claridade e velocidade. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Minha rotina está um pouco lenta, e isto é devido em parte
à claridade do fogo.&nbsp; Eu escolhi 320 x 104 como tamanho do meu buffer, assim eu fiz
um compromisso. A resolução horizontal é boa - 1 pixel por elemento de array, mas a
resolução vertical é um pouco baixa - 2 pixels por elemento de array. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Contudo, eu já vi rotinas onde um buffer de 80 x 50 é usado,
significando que há 4 pixels por elemento para o eixo horizontal e vertical.&nbsp; É
rápido, mas com baixíssima definição. <br>

<ul>
  <li>Faça uma palette agradável </li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Seria idéia boa para ter cor 0 como preto, (0, 0, 0) e a cor
255 como branco - (63, 63, 63).&nbsp; Tudo entre isso deveria ser uma mistura de
amarelo-avermelhado flamejante. Eu suponho você poderia ter chamas verdes se você
quisesse, mas nós vamos usar as chamas que nós conhecemos agora.&nbsp; :) <br>
</p>

<p>Agora o loop principal começa. No loop você deve: 

<ul>
  <li>Criar uma linha de fundo ramdômica, ou duas linhas de fundo </li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Basicamente, você tem um loop como: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; For X := 1 To Xmax Do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp := Random(256);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer[X, Ymax - 1] := Temp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer[X, Ymax] &nbsp;&nbsp;&nbsp;&nbsp;
:= Temp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Codifique isso na linguagem de sua escolha, e você
está no negócio. <br>

<ul>
  <li>Suavize o array:</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Agora este é o único pedaço com macete. O que você tem que
fazer, é como segue: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Comece da segunda linha pra baixo do
buffer. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Mover para baixo, e para cada pixel: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Some os valores dos quatro pixels
que cercam o pixel. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Divida o total por quatro conseguir uma
média. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Tire um da média. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Ponha a média - 1 no array DIRETAMENTE
ACIMA onde o pixel velho estava. <br>
(Você pode alterar isto, e digamos, pôr acima e à direita, e então parecerá que a
chama está sendo soprada pelo vento.) </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Faça isso até você chegar à
última linha. <br>

<ul>
  <li>&nbsp; Copie o array para a tela </li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Se seu array é de 320 x 200, então você pode copiar
elemento-para-pixel.&nbsp; Se não é, então coisas são mais difíceis. O que eu tive
que fazer era copiar uma linha do array para a tela, abaixar uma linha da tela, copiar a
mesma linha do array para a tela, e então entrar numa linha diferente no array e na tela.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Deste modo, eu espalhei o fogo um pouco. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Você vai, é, querer saber exatamente por que meu array é de
320 x 104 e não de 320 x 100.&nbsp; Bem, a razão para isto é bastante simples.&nbsp; Se
eu tivesse usado 320 x 100 como minhas dimensões de array, e então copiasse isso para a
tela, as últimas quatro linhas teriam parecido bem estranhas.&nbsp; Elas não teriam sido
suavizados corretamente, e o resultado final não estaria de todo flamejante.&nbsp; Assim,
eu apenas copiei até a linha 100 para a tela, e deixei o resto pra lá. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; Como uma experiência, tente mudar a terceira linha abaixo no
procedimento de DrawScreen para&nbsp;&nbsp; MOV BX, BufferY&nbsp;&nbsp; e mudar as
dimensões para 320x100 e veja o que acontece. </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; SI, OFFSET Buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Aponta SI para o início do buffer<br>
&nbsp;&nbsp;&nbsp;&nbsp; XOR&nbsp;&nbsp; DI, DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Começa a desenhar em 0, 0<br>
&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; BX, BufferY - 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Perde as 4
últimas linhas do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; buffer. Estas linhas não vão se parecer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; com fogo de jeito nehum.<br>

<ul>
  <li>Volta para o início. </li>
</ul>

<hr>

<p>Bem, não importa o quão bem eu expliquei isso tudo, é muito difícil de ver o que
está acontecendo sem olhar o código. Então agora nós vamos dar uma olhada no programa,
seguindo o que está acontecendo. </p>

<p>Bem, em primeiro lugar, você tem o header. <br>
</p>

<p>&nbsp;&nbsp; .MODEL SMALL&nbsp;&nbsp; ; Segmento de dados &lt; 64K, segmento de código
&lt; 64K<br>
&nbsp;&nbsp; .STACK 200H&nbsp;&nbsp;&nbsp; ; Arruma 512 bytes de espaço para a pilha<br>
&nbsp;&nbsp; .386<br>
</p>

<p>Aqui, eu disse que o programa terá um segmento de código e de dados total de menos
que 128K. Eu vou dar para o programa uma pilha de 512 bytes, e permitir instruções do
386. <br>
</p>

<p>&nbsp; .DATA </p>

<p>CR EQU 13 <br>
LF EQU 10 <br>
</p>

<p>O segmento de dados começa, e eu dou para CR e para LF os valores de &quot;carriage
return&quot; e &quot;line feed&quot; (retorno de carro e alimentação de linha, i.e,
volta pro início e desce uma linha).<br>
</p>

<p>BufferX&nbsp;&nbsp; EQU 320
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Largura do buffer de tela<br>
BufferY&nbsp;&nbsp; EQU 104
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Altura do buffer de tela</p>

<p>AllDone&nbsp;&nbsp; DB CR, LF, &quot;That was:&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFFFFFFF&nbsp;&nbsp;&nbsp; IIIIIII
&nbsp;&nbsp;&nbsp;&nbsp; RRRRRRRRR&nbsp;&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRR&nbsp;&nbsp; RRR&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRR&nbsp;&nbsp; RRR&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRRRRRRR&nbsp;&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFFFFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
RRRRRRRR&nbsp;&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRR&nbsp; RRR&nbsp;&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRR&nbsp;&nbsp; RRR&nbsp;&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; III
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RRR&nbsp;&nbsp;&nbsp; RRR&nbsp; ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFFF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IIIIIII&nbsp;&nbsp;&nbsp;&nbsp; RRRR
&nbsp;&nbsp;&nbsp; RRRR ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;&nbsp;&nbsp; The
demo program from Assembler Tutorial 8. ...&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot; &nbsp;&nbsp;
author, Adam Hyde, at: &quot;, CR, LF<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp; þ blackcat@faroc.com.au&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB CR, LF, &quot;
&nbsp;&nbsp;&nbsp;&nbsp; þ http://www.faroc.com.au/~blackcat&quot;, CR, LF, &quot;$&quot;</p>

<p>Buffer&nbsp;&nbsp;&nbsp; DB BufferX * BufferY DUP (?) ; O buffer de tela</p>

<p>Seed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DW 3749h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; O valor de seed, e metado do meu número de<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; telefone - não em hexa. :)</p>

<p>INCLUDE PALETTE.DAT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; A palette, gerada com<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Autodesk Animator, e um programa simples em <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pascal.<br>
<br>
</p>

<p>Agora, no fim, eu declaro o array e declaro um VALOR DE SEED (semente) para o &nbsp;
procedimento Random que segue. A seed é só um número que é necessário para &nbsp;
começar o procedimento Random, e pode ser qualquer coisa que você quiser. </p>

<p>Eu também economizei algum espaço e pus os dados para a palette em um arquivo externo
que é incluído no código assembly. Dê uma olhada no arquivo. Usar INCLUDE pode
economizar muito espaço e confusão. <br>
</p>

<p>Eu pulei alguns procedimentos que são bastante auto-explicativos, e fui direto para a
procedure DrawScreen. <br>
</p>

<p>DrawScreen PROC<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; SI, OFFSET Buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Aponta SI para o início do
buffer<br>
&nbsp;&nbsp; XOR&nbsp;&nbsp; DI, DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Começa a desenhar em 0, 0<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; BX, BufferY - 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Perde as últimas 4 linhas do buffer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Essas linhas não se parecem<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; com fogo, de jeito nenhum<br>
Row:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; CX, BufferX SHR 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 160 WORDS<br>
&nbsp;&nbsp; REP&nbsp;&nbsp; MOVSW
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Move-as<br>
&nbsp;&nbsp; SUB&nbsp;&nbsp; SI, 320
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Volta pro início da linha do array<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; CX, BufferX SHR 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 160 WORDS<br>
&nbsp;&nbsp; REP&nbsp;&nbsp; MOVSW
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Move-as<br>
&nbsp;&nbsp; DEC&nbsp;&nbsp; BX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Decrementa o número de linhas VGA restantes<br>
&nbsp;&nbsp; JNZ&nbsp;&nbsp; Row
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Terminamos?<br>
&nbsp;&nbsp; RET<br>
DrawScreen ENDP<br>
</p>

<p>Isto também é fácil seguir, e tira proveito de MOVSW, usando-a para mover dados
entre DS:SI e ES:DI. <br>
</p>

<p>AveragePixels PROC<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; CX, BufferX * BufferY - BufferX * 2&nbsp; ; Altera todo o
buffer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; exceto a primeira linha e a última<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; SI, OFFSET Buffer + 320
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Começa da segunda linha</p>

<p>Alter:<br>
&nbsp;&nbsp; XOR&nbsp;&nbsp; AX, AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Zera AX<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AL, DS:[SI]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pega o valor do pixel atual<br>
&nbsp;&nbsp; ADD&nbsp;&nbsp; AL, DS:[SI+1]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pega o valor do pixel à direita<br>
&nbsp;&nbsp; ADC&nbsp;&nbsp; AH, 0<br>
&nbsp;&nbsp; ADD&nbsp;&nbsp; AL, DS:[SI-1]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pega o valor do pixel à esquerda<br>
&nbsp;&nbsp; ADC&nbsp;&nbsp; AH, 0<br>
&nbsp;&nbsp; ADD&nbsp;&nbsp; AL, DS:[SI+BufferX]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Pega o
valor do pixel abaixo<br>
&nbsp;&nbsp; ADC&nbsp;&nbsp; AH, 0<br>
&nbsp;&nbsp; SHR&nbsp;&nbsp; AX, 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Divide o total por quatro</p>

<p>&nbsp;&nbsp; JZ&nbsp;&nbsp;&nbsp; NextPixel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; O resultado é zero?<br>
&nbsp;&nbsp; DEC&nbsp;&nbsp; AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Não, então decrementa de um<br>
<br>
</p>

<p>NOTA:&nbsp; O valor de decay (queda) é UM.&nbsp; Se você mudar a linha acima para,
por exemplo &quot;SUB AX, 2&quot; você vai ver que o fogo não chega tão alto.
Experimente... seja criativo!&nbsp; :) <br>
</p>

<p>NextPixel:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DS:[SI-BufferX], AL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Põe o novo valor no array<br>
&nbsp;&nbsp; INC&nbsp;&nbsp; SI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Próximo pixel<br>
&nbsp;&nbsp; DEC&nbsp;&nbsp; CX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Um a menos para fazer<br>
&nbsp;&nbsp; JNZ&nbsp;&nbsp; Alter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Já fizemos todos?<br>
&nbsp;&nbsp; RET<br>
AveragePixels ENDP<br>
</p>

<p>Agora nós vimos a procedure que faz toda a suavização. Basicamente, nós só temos
um loop que soma os valores de cor dos pixels ao redor de um pixel, carregando os valores
dos pixels antes. Quando ela tem o total em AX, é dividido por quatro para conseguir uma
média. A média é então plotada diretamente sobre o pixel atual. </p>

<p>Para mais informação relativo à instrução de ADC, observe isto em Tutorial 5, e
olhe os programas abaixo: </p>

<p>&nbsp;&nbsp; Var
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Var<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W : Word;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
W : Word;</p>

<p>&nbsp;&nbsp; Begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Asm
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Asm<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; AL, 255
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MOV &nbsp;&nbsp; AL, 255<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp; AL, 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ADD &nbsp;&nbsp; AL, 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; AH, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MOV &nbsp;&nbsp; W, AX<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADC&nbsp; AH, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
End;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; W, AX<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Write(W);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
End;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write(W);<br>
&nbsp;&nbsp; End;</p>

<p>^^^ Este programa returna 256
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^ Este programa
returna 0<br>
</p>

<p>Lembre-se de que ADC é usado para ter certeza que quando um registrador ou variável
não é grande bastante para armazenar um resultado, o resultado não será perdido. <br>
</p>

<p>OK, depois de pular algumas procedures um pouco mais irrelevantes, chegamos ao corpo
principal do programa, que é algo desse tipo: <br>
</p>

<p>Start:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, @DATA<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DS, AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; DS agora aponta para o segmento de dados.<br>
<br>
</p>

<p>Nós apontamos DS primeiramente para o segmento de dados, de modo que possamos ter
acesso a todas nossas variáveis. <br>
</p>

<p>&nbsp;&nbsp; CALL&nbsp; InitializeMCGA<br>
&nbsp;&nbsp; CALL&nbsp; SetUpPalette</p>

<p>MainLoop:<br>
&nbsp;&nbsp; CALL&nbsp; AveragePixels</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; SI, OFFSET Buffer + BufferX * BufferY - BufferX SHL 1<br>
&nbsp;&nbsp; ; SI agora aponta para o início da segunda última linha (?????? - by Krull)<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; CX, BufferX SHL 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Prepara para
pegar BufferX x 2 números randômicos</p>

<p>BottomLine:<br>
&nbsp;&nbsp; CALL&nbsp;&nbsp; Random
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pega um número randômico<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp; DS:[SI], DL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Usa apenas o byte baixo de DX, i.e.,<br>
&nbsp;&nbsp; INC&nbsp;&nbsp;&nbsp; SI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; o número vai ser de 0 --&gt; 255<br>
&nbsp;&nbsp; DEC&nbsp;&nbsp;&nbsp; CX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Um pixel a menos para fazer<br>
&nbsp;&nbsp; JNZ&nbsp;&nbsp;&nbsp; BottomLine
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Já acabamos?<br>
</p>

<p>Aqui, uma nova linha do fundo é calculada. O procedimento Random - muitas graças ao
autor desconhecido da USENET - retorna um valor muito alto em DX:AX. Porém, nós só
requeremos um número de 0 a 255, assim, usando só DL, nós temos tal número. <br>
</p>

<p>&nbsp;&nbsp; CALL&nbsp; DrawScreen
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Copia o buffer para a VGA</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 01H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Checa se foi pressionada alguma tecla<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 16H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Há alguma tecla esperando no buffer?<br>
&nbsp;&nbsp; JZ&nbsp;&nbsp;&nbsp; MainLoop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Não, segue em frente</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 00H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Sim, então pega a tecla<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 16H</p>

<p>&nbsp;&nbsp; CALL&nbsp; TextMode<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 4CH<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AL, 00H<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Volta ao DOS<br>
END Start<br>
</p>

<p>E eu acho que essa última parte também é bem fácil de entender. Eu tentei comentar
o fonte o tanto quanto eu pude, talvez um pouco mais fortemente em algumas partes, mas eu
espero que agora todo mundo tenha uma idéia de como uma rotina de fogo <br>
funciona.</p>

<p>De qualquer maneira, a meta era não lhe ensinar como fazer uma rotina de fogo, mas
como usar arrays, assim se você pegou o negócio do fogo também, então isso é um
bônus. Eu me referi ligeiramente diferentemente aos meus arrays de como eu expliquei
neste tutorial, mas a teoria ainda é a mesma, e lhe mostra outros modos de fazer as
coisas.&nbsp; Se você não entendeu como se usa arrays com isso tudo, então talvez você
nunca entenda, pelo menos não com meu tutorials, sem dúvida. <br>
Ei, vai compra um livro de $50!&nbsp; :) </p>

<hr>

<p>O Tutorial de semana que vem terá: 

<ul>
  <li>E/S de arquivos </li>
  <li>Usando Assembler com C/C++ </li>
  <li>Tabelas de Lookup? </li>
  <li>Macros. </li>
</ul>

<p>Se você deseja ver um tópico discutido em um tutorial futuro, então me escreva, e eu
verei o que eu posso fazer. </p>

<hr>

<p>Não perca!!! Pegue o <a href="tut09pt.htm">tutorial da semana que vem</a> da minha
homepage em: 

<ul>
  <li>http://www.faroc.com.au/~blackcat </li>
  <li><a href="http://www.gecotiies.com/SiliconValley/Park/3174">http://www.gecotiies.com/SiliconValley/Park/3174</a></li>
</ul>

<p>Até semana que vem!</p>

<p>- Adam. <br>
- Krull.</p>
</body>
</html>
