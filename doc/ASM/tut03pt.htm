<html>

<head>
<title>Tutorial 3 - Adam Hyde</title>
</head>

<body bgcolor="#00FFFF">

<p>&nbsp;</p>
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><strong><big>Tutorial de Assembler de
    Adam Hyde 1.0</big></strong><p><small>PARTE 3</small><br>
    <small>Traduzido por Renato Nunes Bastos</small></td>
  </tr>
</table>
</center></div>

<p><br>
Versão&nbsp;&nbsp; :&nbsp; 1.1<br>
Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; 27-02-1996 / online by Renato 01-11-1998<br>
Contato&nbsp; :&nbsp; blackcat@vale.faroc.com.au<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
http://www.faroc.com.au/~blackcat<br>
;Renato&nbsp; :&nbsp;
<a href="mailto:rnbastos@ig.com.br">rnbastos@ig.com.br</a>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://www.geocities.com/SiliconValley/Park/3174">http://www.geocities.com/SiliconValley/Park/3174</a></p>

<hr>

<p align="center"><a href="#asm">Um Programa Assembly</a> | <a href="#flags">O que são
Flags? / Comparações</a></p>

<hr>

<p>Bem-vindos ao terceiro tutorial da série. No último tutorial eu disse que estaríamos
discutindo mais algumas instruções, flags e um verdadeiro programa em Assembly.</p>

<p>Durante este tutorial, você achará os livros &quot;Peter Norton's Guide to
Assembler&quot;, &quot;Peter Norton's Guide to the VGA Card&quot;, ou qualquer um dos
livros &quot;Peter Norton's Guide to...&quot; muito úteis. Você não pode programar em
Assembler sem saber pra que são todas as interrupções e o que são todas as
subfunções.</p>

<p>Eu lhe recomendo conseguir uma cópia desses livros assim que possível.</p>

<hr>

<p><big><strong><a name="asm"><u>Um Programa Assembly</u></a><br>
</strong></big></p>

<p>Eu geralmente não escrevo código 100% em Assembly. É muito mais conveniente<br>
usar uma linguagem de alto nível como C ou Pascal, e usar Assembly para<br>
acelerar os bits lentos. Contudo, você pode querer se torturar e escrever uma<br>
aplicação completamente em Assembly, então aqui vai a configuração básica:</p>
<div align="left">

<table border="1" width="64%">
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">DOSSEG</font></td>
    <td width="78%">diz à CPU como organizar o segmento</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">MODEL</font></td>
    <td width="78%">declara o modelo que vamos usar</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">STACK</font></td>
    <td width="78%">quanta pilha vamos alocar?</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">DATA</font></td>
    <td width="78%">o quê vai no segmento de dados</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">CODE</font></td>
    <td width="78%">o quê vai no segmento de código</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">START</font></td>
    <td width="78%">o início do seu código</td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FF0000"><font color="#FFFF00">END START</font></td>
    <td width="78%">o fim do seu código</td>
  </tr>
</table>
</div>

<p>&nbsp;&nbsp;&nbsp; FATO ENGRAÇADO: Eu sei de alguém que escreveu um clone de Space
Invaders (9K), todo em Assembly. Eu tenho o código fonte, se alguém estiver
interessado...</p>

<p>Okay, agora vamos dar uma olhada no programa de exemplo em que eu não farei
absolutamente nada!</p>

<p>&nbsp;&nbsp;&nbsp; DOSSEG<br>
&nbsp;&nbsp;&nbsp; .MODEL SMALL<br>
&nbsp;&nbsp;&nbsp; .STACK 200h<br>
&nbsp;&nbsp;&nbsp; .DATA<br>
&nbsp;&nbsp;&nbsp; .CODE</p>

<p>START:<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, 4C00h&nbsp;&nbsp; ; AH = 4Ch, AL = 00h<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h<br>
END START</p>

<p>Vamos ver em detalhes. Abaixo, cada uma das frases acima está explicada. 

<ul>
  <li>DOSSEG&nbsp;&nbsp;&nbsp;&nbsp; - isto ordena os segmentos na ordem:</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Segmentos de Código;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Segmentos de Dados;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Segmentos de Pilha.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Não se preocupe muito com isso por enquanto, apenas inclua<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
até que você saiba o que está fazendo. 

<ul>
  <li>MODEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - isso permite à CPU determinar como seu programa
    estáestruturado. Você pode ter os seguintes MODELos:</li>
</ul>

<blockquote>
  <ol>
    <li>TINY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - tanto código quanto dados
      se encaixam no mesmo segmento de 64K.</li>
    <li>SMALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - código e dados estão em segmentos
      diferentes, embora cada um tenha menos de 64K.</li>
    <li>MEDIUM&nbsp;&nbsp;&nbsp; - código pode ser maior que 64K, mas os dados têm que ter
      menos que 64K.</li>
    <li>COMPACT - código &#130; menos de 64K, mas dados podem ter mais que 64K.</li>
    <li>LARGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - código e dados podem ter mais que 64K,
      embora arrays não possam ser maiores que 64K.</li>
    <li>HUGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - código, dados e arrays
      podem ter mais de 64K.</li>
  </ol>
</blockquote>

<ul>
  <li>STACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - isso instrui ao PC para arrumar uma pilha tão
    grande quanto for especificado.</li>
</ul>

<ul>
  <li>DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - permite a você criar um segmento de
    dados.&nbsp; Por exemplo:</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MySegment SEGMENT PARA PUBLIC 'DATA'</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Declare alguns bytes, words, etc.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MySegment ENDS</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Isso é similar a CONSTANTES in Pascal. 

<ul>
  <li>CODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - permite a você criar um segmento de
    código.&nbsp; Ex.:</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MyCodeSegment SEGMENT PARA PUBLIC 'CODE'</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Declare algo</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MyCodeSegment ENDS 

<ul>
  <li>START&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Apenas um label para dizer ao compilador onde a
    parte principal do seu programa começa.</li>
</ul>

<ul>
  <li>MOV&nbsp;&nbsp; AX, 4C00h&nbsp;&nbsp; ; AH = 4Ch, AL = 00h</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Isso move 4Ch para ah, que coincidentemente nos traz de
volta ao DOS.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Quando a interrupção 21h é chamada e AH = 4Ch, de volta
ao DOS lá vamos&nbsp;nós. 

<ul>
  <li>INT&nbsp;&nbsp; 21h</li>
</ul>

<ul>
  <li>END START&nbsp; - Você não tem imaginação?</li>
</ul>

<p>Okay, Espero que você tenha entendido tudo isso, porque agora nós vamos mesmo fazer
algo.&nbsp; Ficou excitado?&nbsp; :)</p>

<p>&nbsp;&nbsp;&nbsp; Neste examplo nós vamos usar a interrupção 21h, (a interrupção
do DOS), para imprimir uma string. Para ser preciso, vamos usar a subfunção 9h, e ela se
parece com isso: 

<ul>
  <li>INTERRUPÇÃO 21h</li>
  <li>SUBFUNÇÃO 9h</li>
</ul>

<p>&nbsp;&nbsp; Requer: 

<ul>
  <li>AH&nbsp;&nbsp;&nbsp;&nbsp; = 9h</li>
  <li>DS:DX&nbsp; = ponteiro FAR para a string a ser impressa. A string deve ser terminada com
    um sinal $.</li>
</ul>

<p>Assim, aqui está o exemplo:</p>

<p>&nbsp;&nbsp;&nbsp; DOSSEG<br>
&nbsp;&nbsp;&nbsp; .MODEL SMALL<br>
&nbsp;&nbsp;&nbsp; .STACK 200h<br>
&nbsp;&nbsp;&nbsp; .DATA</p>

<p>OurString&nbsp;&nbsp; DB&nbsp; &quot;Isto é uma string de caracteres.&nbsp; &quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp; &quot;Você
não tem imaginação? Coloque algo interessante aqui!$&quot;</p>

<p>&nbsp;&nbsp;&nbsp; .CODE</p>

<p>START:<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, SEG OurString&nbsp;&nbsp;&nbsp;&nbsp; ; Move o
segmento onde OurString está&nbsp; <br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DS, AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; para AX, e agora para DS</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET OurString&nbsp; ; Offset de OurString
-&gt; DX<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Subfunção de imprimir strings<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Gera a interrupção 21h</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, 4C00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Subfunção de
saída para o DOS<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Gera a interrupção 21h<br>
END START<br>
</p>

<p>Se você assemblar isso com TASM - TASM SEJALADOQUEVOCECHAMOUELE.ASM então linkar com
TLINK - TLINK SEJALADOQUEVOCECHAMOUELE.OBJ&nbsp; você vai conseguir um arquivo EXE de
cerca de 652 bytes. Você pode usar estes programas no DEBUG com algumas modificações,
mas eu vou deixar isso contigo. Para trabalhar com Assembler puro você _precisa_ de TASM
e TLINK, embora eu ache que MASM &lt;aahh!&gt; faria o mesmo trabalho muito bem.</p>

<p>Agora vamos ao código com um pouco mais detalhado:</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, SEG OurString&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ; Move o segment onde OurString está<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DS, AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; para AX, e agora para DS</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET OurString&nbsp;&nbsp; ; Move o offset
onde OurString está localizado<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Subfunção de
escrita de strings<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Gera a interrupção 21h</p>

<p>Você vai notar que tivemos que usar AX para pôr o endereço do segmento de OurString
em DS. Você vai descobrir que não dá pra referenciar um registrador de segmento
diretamente em Assembler. Na procedure PutPixel do último tutorial, eu movi o endereço
da VGA para AX, e então para ES. A instrução SEG é também introduzida. SEG retorna o
segmento onde a string OurString está localizada, e OFFSET retorna, adivinha o quê?, o
offset do início do segmento para onde a string termina.</p>

<p>Note também que nós usamos DB. DB não é nada de especial, e significa Declare Byte,
que é tudo o que ela faz.&nbsp; DW, Declare Word e DD, Declare Double Word também
existem.<br>
</p>

<p>Você poderia ter também colocado OurString segmento de código, a vantagem é que CS
estaria apontando para o mesmo segmento que OurSting, de modo que você não tem que se
preocupar em procurar o segmento em que OurString está.</p>

<p>O programa acima no segmento de código seria mais ou menos assim:</p>

<p>&nbsp;&nbsp;&nbsp; DOSSEG<br>
&nbsp;&nbsp;&nbsp; .MODEL SMALL<br>
&nbsp;&nbsp;&nbsp; .STACK 200h<br>
&nbsp;&nbsp;&nbsp; .CODE</p>

<p>OurString&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp; &quot;Abaixo o segmento de dados!$&quot;</p>

<p>START:<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, CS<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DS, AX</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET OurString<br>
&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h</p>

<p>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, 4C00h<br>
&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp; 21h<br>
END START</p>

<p>Simples, não?</p>

<p>Nós não vamos ver muitos programas só em Assembly de novo, mas a maioria das
técnicas que usaremos podem ser implementadas em programas só em Assembler.</p>

<hr>

<p><a name="flags"><big><u>Então, o que são flags?</u></big></a><br>
</p>

<p>Esta parte é para meu companheiro Clive que tem me perguntado sobre flags, então lá
vamos nós Clive, com FLAGS.</p>

<p>Eu não me lembro se já introduzimos a instrução CMP (COMPARE) ou não, mas CMP
compara dois números e reflete a comparação nos FLAGS.&nbsp; Para usá-la você faria
algo desse tipo:

<ul>
  <li>CMP&nbsp;&nbsp; AX, BX</li>
</ul>

<p>então seguir com uma instrução como essas abaixo:<br>
</p>

<p><big><u>COMPARAÇÕES SEM SINAL:<br>
</u></big>

<ul>
  <li>JA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula (jump) se AX foi MAIOR que BX;</li>
  <li>JAE&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MAIOR ou IGUAL a BX;</li>
  <li>JB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MENOR que BX;</li>
  <li>JBE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MENOR ou IGUAL a BX;</li>
  <li>JNA&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MAIOR que BX;</li>
  <li>JNAE&nbsp;&nbsp; - pula se AX foi NÃO MAIOR ou IGUAL a BX;</li>
  <li>JNB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MENOR que BX;</li>
  <li>JNBE&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MENOR ou IGUAL a BX;</li>
  <li>JZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de ZERO está setado
    - o mesmo que JE;</li>
  <li>JE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX for IGUAL a BX;</li>
  <li>JNZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de ZERO NÃO está setado - o mesmo
    que JNE;</li>
  <li>JNE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX NÃO for IGUAL a BX;<br>
  </li>
</ul>

<p><big><u>COMPARAÇÕES COM SINAL:<br>
</u></big>

<ul>
  <li>JG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula (jump) se AX foi MAIOR que BX;</li>
  <li>JGE&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MAIOR ou IGUAL a BX;</li>
  <li>JL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MENOR que BX;</li>
  <li>JLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi MENOR ou IGUAL a BX</li>
  <li>JNG&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MAIOR que BX</li>
  <li>JNGE&nbsp;&nbsp; - pula se AX foi NÃO MAIOR ou IGUAL a BX;</li>
  <li>JNL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MENOR que BX;</li>
  <li>JNLE&nbsp;&nbsp;&nbsp; - pula se AX foi NÃO MENOR ou IGUAL a BX;</li>
  <li>JZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de ZERO
    está&nbsp;setado - o mesmo que JE;</li>
  <li>JE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX for IGUAL a BX;</li>
  <li>JNZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de ZERO NÃO está setado - o mesmo
    que JNE;</li>
  <li>JNE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se AX NÃO for IGUAL a BX;<br>
  </li>
</ul>

<p><big><u>NÃO TÃO COMUNS:</u></big><br>

<ul>
  <li>JC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de CARRY está setado;</li>
  <li>JNC&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de CARRY NÃO está setado;</li>
  <li>JO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de OVERFLOW está setado;</li>
  <li>JNO&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de OVERFLOW NÃO está setado;</li>
  <li>JP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de PARIDADE está
    setado;</li>
  <li>JNP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de PARIDADE NÃO está setado;</li>
  <li>JPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se a PARIDADE for PAR - o mesmo que JP;</li>
  <li>JPO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se a PARIDADE for ÍMPAR - o mesmo que JNP;</li>
  <li>JS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de SINAL NÃO está
    setado;</li>
  <li>JNS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pula se o flag de SINAL está setado.</li>
</ul>

<p>Ufa! Meus olhos quase secaram depois de olhar pra essa tela por tanto tempo!<br>
</p>

<p>De qualquer modo, aqui está com o que eles se parecem:</p>
<div align="center"><center>

<table border="1" width="80%">
  <tr>
    <td width="11%" align="center" bgcolor="#FF0000">Flag</td>
    <td width="11%" align="center" bgcolor="#FF0000">SF</td>
    <td width="11%" align="center" bgcolor="#FF0000">ZF</td>
    <td width="11%" align="center" bgcolor="#FF0000">--</td>
    <td width="11%" align="center" bgcolor="#FF0000">AF</td>
    <td width="11%" align="center" bgcolor="#FF0000">--</td>
    <td width="11%" align="center" bgcolor="#FF0000">PF</td>
    <td width="11%" align="center" bgcolor="#FF0000">--</td>
    <td width="12%" align="center" bgcolor="#FF0000">CF</td>
  </tr>
  <tr>
    <td width="11%" align="center" bgcolor="#FFFF00">Bit</td>
    <td width="11%" align="center" bgcolor="#FFFF00">07</td>
    <td width="11%" align="center" bgcolor="#FFFF00">06</td>
    <td width="11%" align="center" bgcolor="#FFFF00">05</td>
    <td width="11%" align="center" bgcolor="#FFFF00">04</td>
    <td width="11%" align="center" bgcolor="#FFFF00">03</td>
    <td width="11%" align="center" bgcolor="#FFFF00">02</td>
    <td width="11%" align="center" bgcolor="#FFFF00">01</td>
    <td width="12%" align="center" bgcolor="#FFFF00">00</td>
  </tr>
</table>
</center></div>

<p><u>Legenda:<br>
</u>&nbsp; SF - Flag de Sinal;<br>
&nbsp; ZF - Flag de Zero;<br>
&nbsp; AF - Flag Auxiliar;<br>
&nbsp; PF - Flag de Paridade.<br>
&nbsp; CF - Flag de Carry (vai um).</p>

<p>Nota: HÁ MUITO MAIS FLAGS PARA APRENDER. Eles serão vistos num Tutorial mais à
frente.</p>

<hr>

<p>COISAS PARA FAZER:</p>

<p>1) Volte ao frame da configuração básica de Assembler e memorize-o.<br>
2) Tenter escrever um programa simples que mostre alguns comentários _criativos_.<br>
3) Aprenda as instruções JUMP menos criptográficos de cor.</p>

<hr>

<p>Okay, no último tutorial eu lhe dei algumas procedures, e pedi para você
comentá-las. Eu não queria uma explicação detalhada do que eles faziam - não se
espera que você saiba isso ainda - apenas um sumário do que cada comando faz.</p>

<p>Ex.:</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, 0003h&nbsp;&nbsp; ; AX agora &#130; igual a 03h;<br>
&nbsp;&nbsp; ADD&nbsp;&nbsp; AX, 0004h&nbsp;&nbsp; ; AX agora &#130; igual a 07h;</p>

<p>Então, aqui vai o conjunto completo das procedures com comentários:<br>
</p>

<p>{ Esta procedure limpa a tela em modo texto }</p>

<p>Procedure ClearScreen(A : Byte; Ch : Char);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { ClearScreen }<br>
&nbsp; mov&nbsp;&nbsp; ax, 0B800h&nbsp;&nbsp;&nbsp; { Move o endereço de vídeo para AX
&nbsp;&nbsp;&nbsp; }<br>
&nbsp; mov&nbsp;&nbsp; es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Aponta ES para o segmento de vídeo&nbsp;&nbsp;&nbsp; }<br>
&nbsp; xor&nbsp;&nbsp; di, di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Zera&nbsp; DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp; mov&nbsp;&nbsp; cx, 2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move
2000 (80x25) para CX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
&nbsp; mov&nbsp;&nbsp; ah, A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o atributo para
AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp; mov&nbsp;&nbsp; al, &amp;Ch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Move o caracter a usar para AL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp; rep&nbsp;&nbsp; stosw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Faz isso
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
End;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ClearScreen
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
</p>

<p>Explicação:</p>

<p>Nós zeramos DI, logo é igual a 0 - o canto esquerdo da tela. Isto é de onde vamos
começar a encher a tela.</p>

<p>Movemos 2000 para CX porque vamos colocar 2000 caracteres na tela.<br>
</p>

<p>{ Esta procedure move o cursor para a posição X, Y }</p>

<p>Procedure CursorXY(X, Y : Word);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp; { CursorXY }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ax, Y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o
valor Y para AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dh, al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Y vai
para DH
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; dec&nbsp;&nbsp; dh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; { rotina baseada em ajustar para zero&nbsp;}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ax, X
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o
valor de X para AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dl, al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { X
vai para &nbsp; DL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; dec&nbsp;&nbsp; dl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; { rotina baseada em ajustar para zero&nbsp;}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ah, 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Chama a função correspondente&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp; xor&nbsp;&nbsp; bh, bh
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Zera&nbsp; BH
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 10h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; { faz isso (põe o cursor na posição)&nbsp;&nbsp;&nbsp;&nbsp; }<br>
End;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ CursorXY
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
</p>

<p>Explicação:</p>

<p>A 'rotina baseada em ajustar para zero' é realizada porque a BIOS refere-se à
posição (1, 1) como (0, 0), e igualmente (80, 25) como (79, 24).<br>
<br>
</p>

<p>Procedure PutPixel(X, Y : Integer; C : Byte; Adr : Word);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { PutPixel }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ax, [Adr]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Move o endereço do VGA em &nbsp;
AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; es, ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Joga AX
em ES
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; bx, [X]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o valor de X
para BX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dx, [Y]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o valor de Y
para DX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; xchg&nbsp; dh, dl
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Daqui pra frente calcula o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; al, [C]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { offset do pixel
a ser plotado&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; di, dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { e põe
este valor em DI.&nbsp; Vamos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; shr&nbsp;&nbsp; di, 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; { ver isso mais tarde - próximo tutorial
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; add&nbsp;&nbsp; di, dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
quando falarmos sobre shifts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; add&nbsp;&nbsp; di, bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
versus muls
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; stosb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; { Guarda o byte em ES:DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
End;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ PutPixel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOTA:&nbsp; Eu estaria muito interessado em
achar uma procedure PutPixel mais rápida que essa. Eu já vi uma inline que faz isso em
metade do tempo, mas mesmo assim, essa é muito quente.<br>
</p>

<p>{ Esta procedure &#130; uma função de delay independente de CPU }</p>

<p>Procedure Delay(ms : Word);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { Delay }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ax, 1000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
Move o número de ms em um segundo para AX&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mul&nbsp;&nbsp; ms
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; { Faz AX = número de ms a esperar
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; cx, dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Prepara para o
delay - põe número de ms&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dx, ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ onde necessário
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ah, 86h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Cria o delay
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 15h<br>
End;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ Delay }</p>

<hr>

<p>Quase todo o fluido saiu do meus olhos agora - é quase meia-noite - então<br>
eu acho melhor parar. Desculpe se os comentários são um pouco curtos, mas eu<br>
preciso dormir!</p>

<p>No próximo tutorial vamos ver: 

<ul>
  <li>Shifts - o que são eles?</li>
  <li>Alguns exemplos de CMP/JMP.</li>
  <li>Como a memória VGA é arrumada, e como acessá-la.</li>
  <li>hum, algum outro grande tópico.</li>
</ul>

<p>Na próxima semana eu vou fazer um esforço para te mostrar com acessar a memória
rapidamente, isto é, o VGA, e lhe dar alguns exemplos.</p>

<p>Se você deseja ver um tópico discutido num tutorial no futuro, escreva-me, e eu vou
ver o que eu posso fazer.</p>

<hr>

<p>Não perca!!! Baixe o <a href="tut04pt.htm">tutorial da próxima semana</a> na minha
homepage: 

<ul>
  <li>http://www.faroc.com.au/~blackcat</li>
  <li><a href="http://www.geocities.com/SiliconValley/Park/3174">http://www.geocities.com/SiliconValley/Park/3174</a></li>
</ul>

<p>Vejo vocês na próxima semana!</p>

<p>- Adam.<br>
- Renato Nunes Bastos</p>
</body>
</html>
