<html>

<head>
<title>Tutorial 4 - Adam Hyde</title>
</head>

<body bgcolor="#00FFFF">
<div align="center"><center>

<table border="5" width="50%">
  <tr>
    <td width="50%" align="center" bgcolor="#FF0000"><strong><big>Tutorial de Assembler de
    Adam Hyde 1.0</big></strong><p><small>PARTE 4</small><br>
    <small>Traduzido por Renato Nunes Bastos</small></td>
  </tr>
</table>
</center></div>

<p><br>
Versão&nbsp;&nbsp; :&nbsp; 1.3<br>
Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; 01-03-1996 /online by Renato 01-11-1998<br>
Contato&nbsp; :&nbsp; blackcat@vale.faroc.com.au<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
http://www.faroc.com.au/~blackcat<br>
;Renato&nbsp; :&nbsp;
<a href="mailto:rnbastos@ig.com.br">rnbastos@ig.com.br</a>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://www.geocities.com/SiliconValley/Park/3174">http://www.geocities.com/SiliconValley/Park/3174</a></p>

<hr>

<p align="center"><a href="#compara">Exemplo de Comparação</a> | <a href="#shift">Shifts
/ Aritmética Hexadecima e Binária</a> | <a href="#VGA">Programado a VGA em Assembler</a></p>

<hr>

<p>Bem-vindos mais uma vez, florescentes programadores Assembler. Os tutoriais parecem
estar ficando populares agora, e eu tenho recebido e-mails pedindo-me para falar sobre o
VGA, então eu vou dar olhada. Isso é basicamente para onde eu tenho conduzido no meu
modo desconjuntado, de qualquer modo, já que programação gráfica não é só
recompensante, é divertido também! Bem, eu acho que é.&nbsp; :)</p>

<p>Primeiramente porém, devemos terminar aquela coisa de CMP/JMP, e falar de shifts.
Quando se está programando em Assembler, a gente acha que comparações, shifts e testar
bits são operações muito comuns.</p>

<hr>

<p><strong><big><a name="compara"><u>Um Exemplo de Comparação</u></a><br>
</big></strong></p>

<p>Eu não vou perder tempo explicando minuciosamente o seguinte exemplo - ele é muito
fácil de entender e você deve pegar a idéia basica seja lá como for.<br>
</p>

<p>&nbsp;&nbsp; DOSSEG<br>
&nbsp;&nbsp; .MODEL SMALL<br>
&nbsp;&nbsp; .STACK 200h<br>
&nbsp;&nbsp; .DATA</p>

<p>FirstString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp; 13, 10, &quot;Este é um
grande tutorial ou o quê? :) - $&quot;<br>
SecondString&nbsp;&nbsp; DB&nbsp; 13, 10, &quot;NÃO? NÃO? O que você quer dizer,
NÃO?$&quot;<br>
ThirdString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp; 13, 10, &quot;Excelente, vamos ouvir
você dizer isso de novo.$&quot;<br>
FourthString&nbsp;&nbsp;&nbsp; DB&nbsp; 13, 10, &quot;Apenas um Y ou N j&nbsp;
basta.$&quot;<br>
ExitString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp; 13, 10, &quot;Bem, deixa pra
lá!$&quot;</p>

<p>&nbsp;&nbsp; .CODE</p>

<p>START:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, @DATA
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Novo modo de dizer:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DS, AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; DS -&gt; SEG segmento de dados</p>

<p>KeepOnGoing:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET FirstString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DX
-&gt; OFFSET FirstString<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Escreve a primeira mensagem</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Pega uma tecla - armazena-a em AX<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 16h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; AL - código ASCII, AH - &quot;scan code&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Ela não ecoa na tela, contudo,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; nós mesmos temos que fazer isso.</p>

<p>&nbsp;&nbsp; PUSH&nbsp; AX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Aqui nós mostramos na tela o caracter<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DL, AL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; note que nós salvamos AX. Obviamente, <br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; usando-se AH para imprimir uma string <br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; destrói-se AX<br>
&nbsp;&nbsp; POP&nbsp;&nbsp; AX</p>

<p>&nbsp;&nbsp; CMP&nbsp;&nbsp; AL, &quot;Y&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Checa se foi teclado 'Y' <br>
&nbsp;&nbsp; JNE&nbsp;&nbsp; HatesTute
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Se foi, continua</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Mostra a mensagem &quot;Excelente...&quot; <br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET ThirdString<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h<br>
&nbsp;&nbsp; JMP&nbsp;&nbsp; KeepOnGoing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Volta ao início e começa de novo</p>

<p>HatesTute:<br>
&nbsp;&nbsp; CMP&nbsp;&nbsp; AL, &quot;N&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Certifica que foi teclado 'N'<br>
&nbsp;&nbsp; JE&nbsp;&nbsp;&nbsp; DontLikeYou
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Infelizmente, sim.</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET FourthString&nbsp;&nbsp;&nbsp;&nbsp; ; Pede ao
usuário para tentar de novo<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h<br>
&nbsp;&nbsp; JMP&nbsp;&nbsp; KeepOnGoing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Deixa ele tentar</p>

<p>DontLikeYou:<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET SecondString&nbsp;&nbsp;&nbsp;&nbsp; ; Mostra a
string &quot;NÃO? NÃO? O que...&quot;<br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; DX, OFFSET ExitString &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Mostra a string &quot;Bem, deixa pra lá!&quot; <br>
&nbsp;&nbsp; MOV&nbsp;&nbsp; AH, 9<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h</p>

<p>&nbsp;&nbsp; MOV&nbsp;&nbsp; AX, 4C00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; Volta para o DOS<br>
&nbsp;&nbsp; INT&nbsp;&nbsp; 21h<br>
END START</p>

<p>Você deveria entender este exemplo, brincar um pouco com ele e escrever algo melhor.
Aqueles com um livro do Peter Norton ou algo semelhante, experimentem as subfunções do
teclado, e veja quais outras combinações de GetKey existem, ou melhor ainda, brinque com
a interrupção 10h e entre em algum modo de vídeo sobrenatural - um que seu PC suporte!
- e use algumas cores.</p>

<hr>

<p><big><strong><u><a name="shift">Shifts</a><br>
</u></strong></big></p>

<p>Um simples conceito, e um que eu já devia ter discutido antes, mas como eu disse - eu
tenho minha própria maneira desconjuntada de fazer as coisas.</p>

<p>Primeiro você vai precisar de entender um pouco de aritmética hexadecimal e binária
- um assunto que eu _deveria_ ter coberto antes. Eu geralmente uso uma calculadora
científica - ei, eu sempre uso uma calculadora, eu não sou estúpido! - mas é bom ser
capaz de saber como multiplicar, somar e converter entre as várias bases.</p>

<p>Você também não pode usar uma calculadora em provas de Computação, não na
Austrália.<br>
</p>

<p>CONVERTENDO DE BINÁRIO PARA DECIMAL:</p>

<p>De Volta ao Tutorial Um, nós vimos como números binários se parecem, então imagine
que eu tenha um número binário de oito dígitos, como:</p>

<p>11001101</p>

<p>O que é isso em decimal??? Há várias formas de converter tal número, e eu uso a
seguinte, que acredito se provavelmente a mais fácil:</p>
<div align="center"><center>

<table border="1" width="77%">
  <tr>
    <td width="22%" align="left">Número Binário</td>
    <td width="7%" align="center">1</td>
    <td width="7%" align="center">1</td>
    <td width="9%" align="center">0</td>
    <td width="7%" align="center">0</td>
    <td width="10%" align="center">1</td>
    <td width="10%" align="center">1</td>
    <td width="10%" align="center">0</td>
    <td width="10%" align="center">1</td>
  </tr>
  <tr>
    <td width="22%" rowspan="2" align="left">Equivalente Decimal</td>
    <td width="7%" align="center">2<sup>7</sup></td>
    <td width="7%" align="center">2<sup>6</sup></td>
    <td width="9%" align="center">2<sup>5</sup></td>
    <td width="7%" align="center">2<sup>4</sup></td>
    <td width="10%" align="center">2<sup>3</sup></td>
    <td width="10%" align="center">2<sup>2</sup></td>
    <td width="10%" align="center">2<sup>1</sup></td>
    <td width="10%" align="center">2<sup>0</sup></td>
  </tr>
  <tr>
    <td width="7%" align="center">128</td>
    <td width="7%" align="center">64</td>
    <td width="9%" align="center">32</td>
    <td width="7%" align="center">16</td>
    <td width="10%" align="center">8</td>
    <td width="10%" align="center">4</td>
    <td width="10%" align="center">2</td>
    <td width="10%" align="center">1</td>
  </tr>
  <tr>
    <td width="22%" align="left">Valor Decimal</td>
    <td width="70%" colspan="8"><p align="center">128+64+0+0+8+4+0+1=</td>
    <td width="10%"><p align="center">205</td>
  </tr>
</table>
</center></div>

<p>Pegou a idéia? Note que para a última linha, seria mais preciso escrever:</p>

<p>&nbsp;&nbsp; 1 x 128 + 1 x 64 + 0 x 32 + 0 x 16 + 1 x 8 + 1 x 4 + 0 x 2 + 1 x 1<br>
=&nbsp;&nbsp;&nbsp;&nbsp; 128 +&nbsp;&nbsp;&nbsp;&nbsp; 64 +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 +
&nbsp;&nbsp;&nbsp;&nbsp; 8 +&nbsp;&nbsp;&nbsp;&nbsp; 4 +&nbsp;&nbsp;&nbsp;&nbsp; 0 +
&nbsp;&nbsp;&nbsp;&nbsp; 1<br>
= 205</p>

<p>Desculpe se isto é um pouco confuso, mas é difícil explicar sem demonstrar.<br>
Aqui vai outro exemplo:</p>
<div align="center"><center>

<table border="1" width="77%">
  <tr>
    <td width="22%" align="left">Número Binário</td>
    <td width="7%" align="center">0</td>
    <td width="7%" align="center">1</td>
    <td width="9%" align="center">1</td>
    <td width="7%" align="center">1</td>
    <td width="10%" align="center">1</td>
    <td width="10%" align="center">1</td>
    <td width="10%" align="center">0</td>
    <td width="10%" align="center">0</td>
  </tr>
  <tr>
    <td width="22%" rowspan="2" align="left">Equivalente Decimal</td>
    <td width="7%" align="center">2<sup>7</sup></td>
    <td width="7%" align="center">2<sup>6</sup></td>
    <td width="9%" align="center">2<sup>5</sup></td>
    <td width="7%" align="center">2<sup>4</sup></td>
    <td width="10%" align="center">2<sup>3</sup></td>
    <td width="10%" align="center">2<sup>2</sup></td>
    <td width="10%" align="center">2<sup>1</sup></td>
    <td width="10%" align="center">2<sup>0</sup></td>
  </tr>
  <tr>
    <td width="7%" align="center">128</td>
    <td width="7%" align="center">64</td>
    <td width="9%" align="center">32</td>
    <td width="7%" align="center">16</td>
    <td width="10%" align="center">8</td>
    <td width="10%" align="center">4</td>
    <td width="10%" align="center">2</td>
    <td width="10%" align="center">1</td>
  </tr>
  <tr>
    <td width="22%" align="left">Valor Decimal</td>
    <td width="70%" colspan="8"><p align="center">0+64+32+16+8+4+0+0=</td>
    <td width="10%"><p align="center">124</td>
  </tr>
</table>
</center></div>

<p>Obs.: 

<ul>
  <li>Você pode usar esta técnica com palavras de 16 ou 32 bits também, apenas faça do
    jeito certo. Ex: Depois de 128, você escreveria 256, depois 512, 1024 e assim por diante.</li>
  <li>Você pode dizer se o equivalente decimal ser&nbsp;par ou ímpar pelo primeiro bit.
    &nbsp; Ex.: No exemplo acima, o primeiro <br>
    bit = 0, então o número é PAR. No primeiro exemplo, o primeiro bit é 1, então o
    número é ÍMPAR.</li>
</ul>

<p>FATO ENGRAÇADO: Caso você não saiba ainda, bit vem de Binary digIT.&nbsp; :)<br>
</p>

<p>CONVERTENDO DE DECIMAL PARA BINÁRIO:</p>

<p>Isso é provavelmente mais fácil que da base-2 para base-10. Para calcular<br>
o que 321 seria em binário, você faria o seguinte:</p>

<p>&nbsp;&nbsp;&nbsp; 321
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp; 256&nbsp; X&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 321 - 256 = 65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp; 128
&nbsp; X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 65
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp; 64&nbsp; X&nbsp; 1<br>
&nbsp;&nbsp;&nbsp; 65&nbsp; -&nbsp; 64 = 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp; 32 &nbsp;
X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp; X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp; X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp; X&nbsp; 0<br>
&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; X&nbsp; 1</p>

<p>E você obteria o número binário - 101000001. Fácil, né?&nbsp; Vamos tentar outro
para ter certeza que sabemos fazer:</p>

<p>&nbsp;&nbsp;&nbsp; 198
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp; 128&nbsp; X 1<br>
&nbsp;&nbsp;&nbsp; 198 - 128 = 70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &nbsp;&nbsp;&nbsp;&nbsp;
64&nbsp; X 1<br>
&nbsp;&nbsp;&nbsp; 70&nbsp; -&nbsp; 64 =&nbsp; 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp; 32&nbsp; X 0<br>
&nbsp;&nbsp;&nbsp; 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp; X 0<br>
&nbsp;&nbsp;&nbsp; 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp; X 0<br>
&nbsp;&nbsp;&nbsp; 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; X 1<br>
&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; -&nbsp;&nbsp; 4 =&nbsp; 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp; X 1<br>
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; -&nbsp;&nbsp; 2 =&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; X 0</p>

<p>E isto nos dá&nbsp; - 11000110.&nbsp; Note como você pode checar o primeiro dígito
para ver se você conseguiu sua conversão certa. Quando eu escrevi o primeiro exemplo, eu
notei que eu fiz um erro quando eu chequei o primeiro bit. No primeiro exemplo, eu
consegui 0 - não muito bom para um número ímpar. Eu entendi o erro e corrigi o exemplo.<br>
</p>

<p>CONVERTENDO DE HEXADECIMAL PARA DECIMAL:</p>

<p>Antes de começar, você deveria saber que o sistema numérico hexadecimal usa os
'dígitos':</p>

<p>&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 0 (decimal)
&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp; 0 (binário)<br>
&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1 (decimal)&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp; 1 (binário)<br>
&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 2 (decimal)&nbsp; =
&nbsp;&nbsp;&nbsp; 10 (binário)<br>
&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 3 (decimal)&nbsp; =
&nbsp;&nbsp;&nbsp; 11 (binário)<br>
&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 4 (decimal)&nbsp; =
&nbsp;&nbsp; 100 (binário)<br>
&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 5 (decimal)&nbsp; =
&nbsp;&nbsp; 101 (binário)<br>
&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 6 (decimal)&nbsp; =
&nbsp;&nbsp; 110 (binário)<br>
&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 7 (decimal)&nbsp; =
&nbsp;&nbsp; 111 (binário)<br>
&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 8 (decimal)&nbsp; =
&nbsp; 1000 (binário)<br>
&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 9 (decimal)&nbsp; =
&nbsp; 1001 (binário)<br>
&nbsp;&nbsp; A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 10 (decimal)&nbsp; =
&nbsp; 1010 (binário)<br>
&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 11 (decimal)&nbsp; =
&nbsp; 1011 (binário)<br>
&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 12 (decimal)&nbsp; =
&nbsp; 1100 (binário)<br>
&nbsp;&nbsp; D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 13 (decimal)&nbsp; =
&nbsp; 1101 (binário)<br>
&nbsp;&nbsp; E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 14 (decimal)&nbsp; =
&nbsp; 1110 (binário)<br>
&nbsp;&nbsp; F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 15 (decimal)&nbsp; =
&nbsp; 1111 (binário)</p>

<p>Você vai comumente ouvir hexadecimal referenciado como hex, ou base-16 e ela é
comumente denotada por um 'h' - ex.: 4C00h, ou um '$', ex.: - $B800.</p>

<p>Trabalhar com hexadecimal não é tão difícil como pode parecer, e converter pra lá
ou pra cá é bem fácil. Como exemplo, vamos converter B800h para decimal:</p>

<p>FATO ENGRAÇADO: B800h é o endereço inicial do vídeo em modo texto para CGA e placas
superiores.&nbsp; :)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; = 4096 x B =
4096 x 11 = 45056<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; =&nbsp; 256 x 8
&nbsp;&nbsp; =&nbsp; 256 x&nbsp; 8&nbsp;&nbsp; =&nbsp; 2048<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; = &nbsp;&nbsp;
16 x 0&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; 16 x&nbsp; 0&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp; 1 x 0&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp; 1 x&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp; 0</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logo B800h = 45056 + 2048 + 0 +
0 = 47104</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Obs.:&nbsp; Para números em
hexadecimal maiores que FFFFh (65535 em decimal), você somente segue o mesmo procedimento
como para binário, logo, para o quinto dígito hexadecimal, você multiplicaria por
65535.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tecle 16 X X na sua calculadora, e fique apertando =.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Você verá os números que precisaria usar. O mesmo aplica-se<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
para binário. Ex.:&nbsp; 2 X X e = lhe daria 1, 2, 4, 8, 16...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
etc.</p>

<p>OK, isso pareceu bem fácil. Eu acho que nem precisamos de um segundo exemplo.<br>
Vamos dar uma olhada em:<br>
</p>

<p>CONVERTENDO DE DECIMAL PARA HEXADECIMAL:</p>

<p>&nbsp;&nbsp;&nbsp; Mais uma vez, o mesmo tipo de procedimento como usamos para
binário. Logo, para converter 32753 para hexadecimal, você faria assim:<br>
</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32753 / 4096
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp; 7 (decimal) = 7h</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32753 - (4096 x 7)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4081</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4081 /&nbsp; 256
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 15 (decimal) = Fh</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4081 - (256 x 15)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 241</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 241 / 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 15 (decimal) = Fh</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 241 - (16 x 15)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 / 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &nbsp; 1 (decimal) = 1h<br>
</p>

<p>Assim, eventualmente temos 7FF1h como resposta. Este não é particularmente um bom
processo e requer alguma explicação.</p>

<p>&nbsp;&nbsp; 1) Quando você divide 32753 por 4096 você consegue 7.9963379... Não
estamos interessados no lixo .9963379, só pegamos o 7, já que 7 é o maior número
inteiro que podemos usar.</p>

<p>&nbsp;&nbsp; 2) O resto da operação acima é 4081. Devemos agora realizar a mesma
operação nisso, mas com 256.&nbsp; Dividindo 4081 por 256 nos dá 15.941406... &nbsp;
Novamente, pegamos só o 15.</p>

<p>&nbsp;&nbsp; 3) Agora temos um resto de 241.&nbsp; Dividindo isto por 16 nos dá
15.0625.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pegamos o 15, e calculamos o resto.</p>

<p>&nbsp;&nbsp; 4) Nosso último resto acontece que é um. Dividindo isso por um chegamos
a, você advinhou - um.&nbsp; VOCÊ NÃO DEVERIA CONSEGUIR UMA RESPOSTA COM MUITAS CASAS
DECIMAIS AQUI. SE VOCÊ TEM - VOCÊ CALCULOU ERRADO.</p>

<p>É um processo muito imundo, mas funciona.&nbsp; Eu não uso isso, exceto quando eu
tenho que usar - eu não sou maluco. Eu uso uma calculadora científica, ou a calculadora
do Windows &lt;brrrrr&gt; se eu precisar.</p>

<hr>

<p>OK, agora que já lidamos com os cálculos horripilantes, você já está pronto para
os shifts. Há geralmente 2 formas da instrução shift - SHL (shift left/esquerda) e SHR
(shift right/direita). Basicamente, tudo o que essas instruções fazem é deslocar uma
expressão para a esquerda ou direita um certo número de bits. Sua principal vantagem é
a habilidade de lhe deixar substituir multiplicações lentas com shifts mais rápidos.
Você vai achar que isso acelerará pra caramba os algoritmos de pixel/linhas/círculo. </p>

<p>Os PC's estão ficando cada vez mais rápidos a cada dia - um pouco rápido demais pro
meu gosto. De volta aos dias do XT - a multiplicação era _realmente_ lenta - talvez
levando atá 4 segundos para certas operações. Hoje em dia isso não acontece assim, mas
é uma boa idéia otimizar seu código.</p>

<p>Quando nós plotamos um pixel na tela, temos que encontar o offset do pixel a plotar.
Basicamente, o que fazemos é multiplicar a posição Y por 320, somar a posição X, e
somar isso ao endereço A000h.</p>

<p>Assim basicamente, temos:&nbsp;&nbsp; A000:Yx320+X</p>

<p>Agora, seja lá quão rápido seu maravilhoso 486 ou Pentium é, isso poderia se feito
um pouco mais rápido. Vamos reescrever aquela equação acima, assim, vamos usar alguns
números diferentes:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset = Y
x 2<sup>8</sup>&nbsp;&nbsp; +&nbsp; Y x 2<sup>6</sup>&nbsp; + X<br>
Ou:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset = Y
x 256 +&nbsp; y x 64 + X</p>

<p>Reconhece esses números? Eles parecem terrivelmente com aqueles que nós vimos naquela
tabela de conversão binário-decimal. Contudo, nós ainda estamos usando multiplicação.
Como podemos incorporar shifts?</p>

<p>Que tal:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Offset =
Y SHL 8 + Y SHL 6 + X</p>

<p>Agora, isso é _muito_ mais rápido, já que tudo o que o computador tem que fazer é
um shift à esquerda com o número - muito melhor. Note que o shift à esquerda AUMENTA o
número, e o shift à direita DIMINUI o número.</p>

<p>Aqui está um exemplo que pode te ajudar se você ainda está em dúvida no que está
acontecendo. Digamos que estamos trabalhando em base-10 - decimal. Agora Peguemos o
número 36 como exemplo. &quot;Shiftando&quot; este número à esquerda de 1,<br>
temos:</p>

<p>&nbsp; 36&nbsp; +&nbsp; 36
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 72</p>

<p>Agora SHL 2:</p>

<p>&nbsp; 36&nbsp; +&nbsp; 36&nbsp; +&nbsp; 36&nbsp; +&nbsp; 36
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 144</p>

<p>E SHL 3:<br>
&nbsp; 36 +&nbsp; 36&nbsp;&nbsp; +&nbsp; 36&nbsp; +&nbsp; 36&nbsp; +&nbsp; 36&nbsp; +
&nbsp; 36&nbsp; +&nbsp; 36&nbsp; +&nbsp; 36&nbsp;&nbsp; = 288</p>

<p>Notou os núeros que se formaram? Havia 2 36's com SHL 1, 4 36's com SHL 2 e 8 36's com
SHL 3. Seguindo este padrão, seria justo assumir que 36 SHL 4 equivalerá a 36 x 16.</p>

<p>Note porém, o que está realmente acontecendo. Se você fosse trabalhar com o valor
binário de 36, que é mais ou menos isso: 100100, e então shiftasse 36 à esquerda de 2,
você teria 144, ou 10010000. Tudo o que a CPU faz na verdade é colocar alguns 1's e 0's
extras na posição de memória.<br>
</p>

<p>Como outro exemplo, pegue o número binário 1000101. Se fizermos um shift à esquerda
de 3, terminaríamos com:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 0 0 1 0 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;---------- SHL 3<br>
&nbsp; 1 0 0 0 1 0 1 0 0 0</p>

<p>Agora vamos deslocar o número 45 à DIREITA de 2 unidades. Em binário isso é 101101.
De onde:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 1 1 0 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHR 2 ----&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 1 1</p>

<p>Notou o que ocorreu? É muito mais fácil para a CPU apenas mover alguns bits
(aproximadamente 2 unidades de clock), do que multiplicar um número. (Pode demorar até
133 unidades de clock).</p>

<p>Nós vamos usar bastante shifts quando estivermos programando a VGA, assim, tenha
certeza de que você entendeu os conceitos por trás disso.<br>
</p>

<hr>
<div align="center"><center>

<table border="5" width="41%">
  <tr>
    <td width="100%" bgcolor="#FF0000"><p align="center"><big>PROGRAMANDO A <a name="VGA">VGA</a>
    EM ASSEMBLER &nbsp; </big></td>
  </tr>
</table>
</center></div>

<p>Eu tenho recebido um monte de mails me pedindo para cobrir a VGA. Então, para todos os
que pediram, nós estaremos gastando a maior parte do nosso tempo, mas não todo, em
programar a VGA. Além do mais, não querem todos programar<br>
com gráficos?</p>

<p>Quando nós falamos sobre programar a VGA, nós estamos geralmente falando do modo 13h,
ou um de seus parentes. Em VGA padrão este é o _único_ modo de usar 256 cores, e é
provavelmente um dos modos mais fáceis também. Se você já tentou experiências com a
SVGA, você vai entender o pesadelo que é para o programador dar suporte a todas as
diferentes placas SVGA que existem - exceto se você usar VESA que é o que discutiremos
outra hora. A grande vantagem do modo padrão 13h é que você sabe que todas as placas
VGA que existem vão suportá-lo. As pessoas hoje frequentemente ignoram o modo 13h,
achando a resolução muito granulada para os padrões de hoje, mas não se esqueça que
Duke Nukem, DOOM, DOOM II, Halloween Harry e a maioria dos jogos da Apogee usam este modo
para realizar alguns grandes efeitos.</p>

<p>A grande coisa sobre o modo 13h - isto é 320x200x256 caso você desconheça, é que
acessar a VGA RAM é incrivelmente fácil. Como 320 x 200 é igual a&nbsp; 64,000, é
possível encaixar a tela inteira em um segmento de 64K.</p>

<p>As más notícias são que o modo padrão 13h realmente só te dá uma página para
usar, seriamente embaraçante para scroll e page-flipping. nós vamos cobrir mais tarde
estes assuntos, como entrar em seus próprios modos - e modo X que evitará esses
problemas.<br>
</p>

<p>Então, como entrar no modo padrão 13h?</p>

<p>A resposta é simples. Usamos a interrupção 10h - interrupção de vídeo, e chamamos
a subfunção 00h - seleciona o modo. Em Pascal, você poderia declarar uma procedure como
esta:</p>

<p>Procedure Init300x200;&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { Init300x200 }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ah, 00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Acerta o modo de vídeo }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; al, 13h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Usa o modo 13h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 10h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ Faz isso
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
End;&nbsp;&nbsp;&nbsp; { Init300x200 }<br>
</p>

<p>você também pode ver:</p>

<p>&nbsp;&nbsp; mov&nbsp;&nbsp; ax, 13h<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 10h</p>

<p>Isso é perfeitamente correto, e provavelmente economiza um tempo de clock por não
colocar 00h em AH e então 13h em AL, mas é mais correto usar o primeiro exemplo.<br>
</p>

<p>OK, então estamos no modo 13h, mas o que podemos realmente fazer nele, além de olhar
para uma tela em branco? Poderíamos voltar ao modo texto usando:</p>

<p>&nbsp;&nbsp; mov&nbsp;&nbsp; ah, 00h<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; al, 03h<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 10h</p>

<p>Mas isso é um pouco idiota. Porque não pintar um pixel?</p>

<hr>

<p>Há inúmeros modos de colocar um pixel na tela. O modo mais fácil em Assembler<br>
é usar interrupções. Você faria mais ou menos assim em Pascal:</p>

<p>Procedure PutPixel(X, Y : Integer; Color : Byte);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { PutPixel }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ah, 0Ch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
subfunção de desenhar pixel&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; al, [Color]&nbsp;&nbsp;&nbsp; { Move a cor a plotar para AL
&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; cx, [X]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Move o valor X para CX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dx, [Y]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Move o valor Y para DX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; bx, 1h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { BX = 1, p&nbsp;gina 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; int&nbsp;&nbsp; 10h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ Plota
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
End;&nbsp;&nbsp;&nbsp; { PutPixel }<br>
</p>

<p>Contudo, mesmo isso sendo em Assembler, não é particularmente rápido. Por quê?,
você pergunta. Porque isso usa interrupção. Interrupções são ótimas para entar e
sair de modos de vídeo, ligar e desligar o cursor, etc... mas não para gráficos.</p>

<p>Você pode imaginar interrupções como uma secretária eletrônica. &quot;A CPU está
ocupada neste momento, mas se você deixar sua subfunção após o sinal - nós entraremos
em contato.&quot;</p>

<p>Não é bom. Vamos usar a técnica que discutimos anteriormente durante shifts. O que
queremos fazer é botar o valor da cor que desejamor plotar na VGA diretamente. Para fazer
isso, precisamos mover o endereço da VGA para ES, e calcular o offset do pixel que
queremos plotar. Um exemplo disso é mostrado abaixo:</p>

<p>Procedure PutPixel(X, Y : Integer; Color : Byte);&nbsp;&nbsp; Assembler;</p>

<p>Asm&nbsp;&nbsp;&nbsp;&nbsp; { PutPixel }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; ax, 0A000h&nbsp;&nbsp; { Move o segmento da VGA para AX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; es, ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { e agora para ES
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; bx, [X]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o valor X para BX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; dx, [Y]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move o valor Y para DX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; di, bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move X para DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; bx, dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Move Y para BX
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; shl&nbsp;&nbsp; dx, 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
Nesta parte usamos shifts para multiplicar }<br>
&nbsp;&nbsp; shl&nbsp;&nbsp; bx, 6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Y
por 320
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; add&nbsp;&nbsp; dx, bx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Agora somamos X ao valor
acima calculado, }<br>
&nbsp;&nbsp; add&nbsp;&nbsp; di, dx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { dando DI = Y x 320 +
X
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; mov&nbsp;&nbsp; al, [Color]&nbsp;&nbsp;&nbsp; { Põe a cor a plotar em AL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp; stosb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ Põe o byte, AL, em ES:DI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
End;&nbsp;&nbsp;&nbsp; { PutPixel }</p>

<p>Esta procedure é rápida o suficiente para começar, embora eu tenha dado uma muito
mais rápida uns tutoriais atrás que usa uma técnica genial para pegar DI.</p>

<hr>

<p>OK, acho que é o suficiente para essa semana. Brinque com as rotinas de PutPixel e
veja o que você pode fazer com elas. Para aqueles com um livro do Peter Norton, veja que
outros procedimentos você pode fazer usando interrupções.<br>
</p>

<p>COISAS PARA FAZER:</p>

<p>&nbsp;&nbsp;&nbsp; 1) Cobrimos muita coisa nesse tutorial, e alguns conceitos
importantes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; estão nele. Certifique-se de estar comfort&nbsp;vel
com comparações, porque<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vamos começar a testar bits em breve.</p>

<p>&nbsp;&nbsp;&nbsp; 2) Tenha certeza que entendeu aquela coisa de binário -&gt;
decimal,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal -&gt; binário, decimal -&gt; hex e hex -&gt;
decimal. Faça você mesmo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alguns exemplos de soma e teste suas respostas com a
calculadora do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows.</p>

<p>&nbsp;&nbsp;&nbsp; 3) você _deve_ entender shifts. Se você ainda tem problemas, faça
algumas<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expressões num papel e teste suas respostas num
programa como:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Begin&nbsp;&nbsp; { Main }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteLn(45 SHL 6);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadLn;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End.&nbsp;&nbsp;&nbsp; { Main }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e/ou a calculadora do Windows.</p>

<p>&nbsp;&nbsp;&nbsp; 4) Dê uma olhada na parte de VGA, e certifique-se de ter pego a
teoria<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; por trás disso, porque na próxima semana vamos
entrar a fundo nisso.</p>

<p>Semana que vem vou tentar colocar alguns exemplos em C/C++ além de Pascal <br>
para vocês programadores de C aí fora.</p>

<hr>

<p>No próximo tutorial vamos ver: 

<ul>
  <li>Como a VGA é arrumada</li>
  <li>Como podemos desenhar linas e círculos</li>
  <li>Pegando e acertando a palette em Assembler</li>
  <li>Fades</li>
  <li>Alguns exemplos em C/C++</li>
</ul>

<p>Se você deseja ver um tópico discutido num tutorial no futuro, escreva-me, e eu vou
ver o que eu posso fazer.</p>

<hr>

<p>Não perca!!! Baixe o <a href="tut05pt.htm">tutorial da próxima semana</a> na minha
homepage: 

<ul>
  <li>http://www.faroc.com.au/~blackcat</li>
  <li><a href="http://www.geocities.com/SiliconValley/Park/3174">http://www.geocities.com/SiliconValley/Park/3174</a></li>
</ul>

<hr>

<p>Vejo vocês na próxima semana!</p>

<p>- Adam.<br>
- Renato Nunes Bastos</p>

<p>&quot; Eu _nunca_ escrevo código com bugs, eu apenas coloco algumas características a
mais sem querer! &quot;</p>
</body>
</html>
